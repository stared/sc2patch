# SC2Patches Project Guidelines

## Code Quality

- **Python 3.12** required
- **Type hints** mandatory for all functions (checked with `ty`)
- **Formatting** with `ruff` (line length: 100)
- **Strict Pydantic models** - validate all data

## Error Handling Philosophy

- **Fail fast, fail loud** - NEVER pass errors silently
- Raise exceptions immediately on validation failures
- Use custom exceptions (e.g., `ValidationError`, `DownloadError`)
- Provide clear error messages with context
- Exit with code 1 on failures

## NO CONTENT TRUNCATION

- **NEVER slice content** like `html_content[:80000]` - this may cut crucial information
- If content is too long for LLM, convert to markdown or extract relevant sections first
- Use proper HTML-to-markdown conversion (e.g., `markdownify`) to reduce size while preserving structure

## NO DEFENSIVE PROGRAMMING

- **CRITICAL RULE**: Do NOT add fallbacks or "if this fails, try that" patterns
- Pick ONE extraction method based on actual data inspection
- If it fails, analyze WHY and fix THAT specific issue
- ONLY add conditionals if you've VERIFIED different files have different formats
- Check actual files, don't guess or assume
- Avoid multiple fallback patterns - they hide real problems

## DATA VERIFICATION

- **Don't use grep for JSON verification** - unreliable (misses variations, escaping issues)
- Always use Python scripts to load and inspect JSON data properly
- Use Gemini 3 Pro or Gemini Consultant to analyze and verify data
- Example - BAD: `grep "creep_tumor" data/processed/patches/*.json`
- Example - GOOD: Load all JSON files with Python, iterate and check with Gemini

## VERIFY ALL LINKS

- When adding any URL or link, ALWAYS verify it exists and has expected content
- Use `curl` or WebFetch to check before committing
- This includes: GitHub repos, documentation links, external resources
- Don't assume URL patterns - check the actual page loads correctly

## Module Design

- **Modular functions** - each function does one thing
- **Explicit validation** after each pipeline stage
- **Progress visibility** - use Rich for progress bars and logging
- **Type safety** - use Pydantic models for all data structures

# Remarks

- If you need to test something with a script, create a script file and run
  Run Python with `uv` - never bare `python3` or `python`.
- DO NOT edit files with `cat`

## Data Pipeline

The pipeline has 4 stages:

1. **Download** (`scripts/1_download.py`) - Fetch HTML from Blizzard News
2. **Parse** (`scripts/2_parse.py`) - Extract structured data with LLM via OpenRouter
3. **Validate** (`scripts/3_validate.py`) - Check completeness
4. **Export** (`scripts/4_export_for_viz.py`) - Copy data to visualization

Each stage:
- Takes input from previous stage
- Generates timestamped markdown log in `data/logs/`
- Fails loudly on errors (exit code 1)

**Single source of truth:** `data/patch_urls.json` (only manually edited file)

**API Keys:** `OPENROUTER_API_KEY` is stored in `.env` file (not committed to git)

**LLM Model:** `google/gemini-3-pro-preview` via OpenRouter (defined in `src/sc2patches/llm_config.py`)

## Pipeline Integrity

**NEVER manually edit files in `data/processed/patches/`** - these are generated by the pipeline and manual changes will be overwritten on the next pipeline run.

If data is wrong:
1. **Fix the pipeline** (scripts or parsing logic)
2. **Reparse only affected files** using `--only` flag (e.g., `uv run python scripts/2_parse.py --only "4.0"`)
3. **Don't rerun entire pipeline** unless necessary - parsing is time-consuming and costs API credits

If a patch file has no HTML source (orphaned data):
1. Find the correct URL (Blizzard News, archive)
2. Add to `data/patch_urls.json`
3. Run download → parse pipeline for that patch
4. Or delete the orphaned file if no valid source exists

**Quick start:**
```bash
uv run python scripts/1_download.py
uv run python scripts/2_parse.py  # Uses OPENROUTER_API_KEY from .env
uv run python scripts/3_validate.py
uv run python scripts/4_export_for_viz.py
```

## Testing

### Python
Before committing:
```bash
uv run ruff format .
uv run ruff check .
uv run ty check src/
```

### TypeScript (Visualization)
```bash
cd visualization
pnpm lint           # Run ESLint
pnpm build          # Production build (includes TypeScript checking via tsc -b)
pnpm dev            # Start dev server (localhost:5173)
```

## Project Structure

```
sc2patches/
├── DATA.md                  # Patch coverage, known issues
├── data/
│   ├── patch_urls.json      # ← ONLY manually edited file
│   ├── logs/                # Timestamped execution logs
│   ├── raw_html/            # Downloaded HTML
│   ├── raw_patches/         # Human-readable Markdown
│   └── processed/patches/   # Final JSON data (one per patch)
├── src/sc2patches/          # Python library
│   ├── logger.py            # Markdown log generation
│   ├── download.py          # Download & convert logic
│   └── parse.py             # LLM parsing logic
├── scripts/                 # Pipeline scripts
│   ├── 1_download.py        # Stage 1: Download
│   ├── 2_parse.py           # Stage 2: Parse with LLM
│   ├── 3_validate.py        # Stage 3: Validate
│   └── 4_export_for_viz.py  # Stage 4: Export
├── visualization/           # React + Vite visualization
│   ├── src/                 # React components
│   └── public/data/         # Exported data (copies from data/)
└── pyproject.toml           # Python dependencies (uv)
```

## Data Format

All patches use this JSON structure:
```json
{
  "metadata": {
    "version": "5.0.9",
    "date": "2022-03-08",
    "url": "https://..."
  },
  "changes": [
    {
      "entity_id": "protoss-void_ray",
      "raw_text": "Cost increased from 200 to 250",
      "change_type": "nerf"
    }
  ]
}
```

**change_type classification:**
- `"buff"` - Entity becomes stronger (cost reduced, damage increased, etc.)
- `"nerf"` - Entity becomes weaker (cost increased, damage reduced, etc.)
- `"mixed"` - Has both positive and negative aspects

## Conventions

- Use `Path` objects, not strings for file paths
- Use `httpx` for HTTP requests
- Rich console for all user-facing output
- Run Python with `uv`, TypeScript with `pnpm`
- Hard validation: fail fast with clear errors, never silent failures
- **ALWAYS ASK before committing** - never commit without explicit user confirmation
- When needed, manually check Blizzard websites or Liqudidpedia, e.g. https://liquipedia.net/starcraft2/Units_(Legacy_of_the_Void) and its pages, e.g. https://liquipedia.net/starcraft2/Factory_(Legacy_of_the_Void), https://liquipedia.net/starcraft2/Stalker_(Legacy_of_the_Void) or https://liquipedia.net/starcraft2/Chitinous_Plating (to show you patters for buildings, units, upgrades). Useful websites: https://liquipedia.net/starcraft2/Upgrades and for patches - https://liquipedia.net/starcraft2/Patches.

## Visualization

```
visualization/
├── src/
│   ├── App.tsx                      # Main component: data, state, UI
│   ├── types.ts                     # TypeScript definitions
│   ├── utils/
│   │   ├── patchGridRenderer.ts     # D3 rendering class
│   │   ├── uxSettings.ts            # UX config (colors, layout, timing)
│   │   └── dataLoader.ts            # Data fetching
│   ├── index.css                    # Global styles
│   └── main.tsx                     # React entry point
└── public/
    ├── data/                        # Exported patch data
    └── assets/units/                # Unit/building images
```

**Architecture:**
- **App.tsx**: Single component orchestrating everything (data, state, rendering, UI)
- **patchGridRenderer.ts**: D3 class (render, layout, elements)
- **uxSettings.ts**: All colors, sizes, timings centralized
- **Targeted D3 imports**: Only d3-selection, d3-transition, d3-ease (not full d3)

**Animation rules:**

Selecting unit (grid → filtered):
1. Fade out irrelevant entities
2. Move selected unit to filtered position
3. Show change notes (fade in after movement)

Deselecting (filtered → grid):
1. Selected unit moves back to grid position
2. Previously visible patches move to new positions
3. Newly appearing elements: fade in at final position only - **NO MOVEMENT**

**Critical:**
- All timing in `uxSettings.ts` (never inline)
- Clicking selected unit deselects it
- After deselection, positions must match original grid exactly